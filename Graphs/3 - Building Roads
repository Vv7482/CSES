// Interms of time complexity the code is optimal but minor changes can be done in implementation.

#include <bits/stdc++.h>
using namespace std;
#define int long long
 
void BFS(int i , vector<vector<int>> &adj , vector<int> &vis){
    queue<int> q;
	q.push(i);
	vis[i] = 1;
	while(!q.empty()){
		int curr = q.front();
		q.pop();
		for(int j=0 ; j<adj[curr].size() ; j++){
			if(vis[adj[curr][j]] == -1){
				q.push(adj[curr][j]);
				vis[adj[curr][j]] = 1;
			}
		}
	}
	return;
}
 
void solve() {
	int n,m;
	cin>>n>>m;
	vector<vector<int>> adj(n+1);
	for(int i=0 ; i<m ; i++){
		int a,b;
		cin>>a>>b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	} 
	vector<int> vis(n+1,-1);
	vector<int> ans;
	for(int i=1 ; i<=n ; i++){
		if(vis[i] == -1){
			ans.push_back(i);
			BFS(i,adj,vis);
		}
	}
 
	int len = ans.size();
	cout<<len-1<<'\n';
	for(int i=1 ; i<len ; i++){
		cout<<ans[0]<<' '<<ans[i]<<'\n';
	}
	return;
}
 
signed main() {
    	ios_base::sync_with_stdio(0);
    	cin.tie(0);
    	cout.tie(0);
 
    	solve();
}
